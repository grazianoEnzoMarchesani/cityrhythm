// utils.js - Contains general utility functions

import { PRESENCE_POINTS_DENSITY_FACTOR, MAX_PRESENCE_POINTS, PRESENCE_STATIC_POINTS_RATIO } from '../data/config.js';

/**
 * Converts an hour index (0-167) to a "Day HH:00" label.
 * Example: 0 -> "Mon 00:00", 25 -> "Tue 01:00"
 * @param {number} hourIndex - The index from 0 to 167.
 * @returns {string} The formatted label or "N/A".
 */
export function hourToLabel(hourIndex) {
    // Input validation
    if (typeof hourIndex !== 'number' || hourIndex < 0 || hourIndex > 167) {
        // console.warn("Invalid hourIndex passed to hourToLabel:", hourIndex);
        return "N/A";
    }

    const days = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    // Index 0 corresponds to Monday 00:00
    const dayIndex = Math.floor(hourIndex / 24);
    const hourOfDay = hourIndex % 24;

    // Ensure dayIndex is within bounds (should be by previous check, but safer)
    if (dayIndex < 0 || dayIndex >= days.length) {
        return "N/A"; // Should not happen if input validation is correct
    }

    const dayName = days[dayIndex];
    // Pad hour with leading zero if needed (e.g., 1 -> "01")
    const hourString = hourOfDay.toString().padStart(2, '0');

    return `${dayName} ${hourString}:00`;
}

/**
 * Converts a timeline hour index (0-167, Mon 00:00 to Sun 23:00)
 * to a JavaScript Date object day of the week (0=Sun, 1=Mon, ..., 6=Sat) and hour (0-23).
 * @param {number} timelineHourIndex - The index from 0 to 167.
 * @returns {{jsDayOfWeek: number, hour: number}} Object containing jsDayOfWeek (-1 if invalid) and hour (-1 if invalid).
 */
export function getDateTimeFromIndex(timelineHourIndex) {
    if (typeof timelineHourIndex !== 'number' || timelineHourIndex < 0 || timelineHourIndex > 167) {
        return { jsDayOfWeek: -1, hour: -1 };
    }
    // timelineDayIndex: 0=Mon, 1=Tue, ..., 6=Sun
    const timelineDayIndex = Math.floor(timelineHourIndex / 24);
    const hour = timelineHourIndex % 24;

    // Convert timelineDayIndex to JavaScript day index (0=Sun, 1=Mon, ...)
    // Monday (index 0) -> 1
    // Tuesday (index 1) -> 2
    // ...
    // Sunday (index 6) -> 0
    const jsDayOfWeek = (timelineDayIndex + 1) % 7;

    return { jsDayOfWeek, hour };
}


/**
 * Calculates the bounding box for a GeoJSON object using Turf.js.
 * Returns a Mapbox GL JS LngLatBounds object.
 * @param {object} geojsonData - The GeoJSON object (FeatureCollection or Feature).
 * @returns {mapboxgl.LngLatBounds | null} A Mapbox bounds object or null if invalid.
 */
export function getGeoJsonBounds(geojsonData) {
    // Check if Turf.js is available
    if (typeof turf === 'undefined') {
        console.error("Turf.js is required for getGeoJsonBounds but not loaded.");
        return null;
    }

    // Basic validation of input GeoJSON
    if (!geojsonData || (geojsonData.type === 'FeatureCollection' && (!geojsonData.features || geojsonData.features.length === 0))) {
        // console.warn("getGeoJsonBounds called with empty or invalid GeoJSON.");
        return null;
    }

    try {
        // Calculate bounding box using Turf
        const bbox = turf.bbox(geojsonData); // [minLng, minLat, maxLng, maxLat]

        // Validate the bounding box result
        if (!bbox || bbox.length !== 4 || bbox.some(isNaN)) {
             // Sometimes turf.bbox returns Infinity/-Infinity, check for that too
             if (bbox && bbox.length === 4 && bbox.some(coord => !isFinite(coord))) {
                 console.warn("Turf.bbox generated non-finite bounds:", bbox);
                 return null;
             }
            throw new Error("Invalid bbox generated by Turf.");
        }

        // MODIFICATO: Use mapboxgl.LngLatBounds
        // Create a Mapbox LngLatBounds object
        // Note: The constructor takes ([west, south], [east, north]) or (lngLatLike, lngLatLike)
        const bounds = new mapboxgl.LngLatBounds(
            [bbox[0], bbox[1]], // Southwest corner (minLng, minLat)
            [bbox[2], bbox[3]]  // Northeast corner (maxLng, maxLat)
        );

        // Optional: Check if bounds are valid (e.g., sw.lng <= ne.lng) - LngLatBounds handles wrap-around
        // console.log("Generated bounds:", bounds);
        return bounds;

    } catch (error) {
        console.error("Error calculating GeoJSON bounds:", error);
        return null;
    }
}


/**
 * Fits the map view to the bounds of the provided GeoJSON data.
 * @param {mapboxgl.Map} map - The Mapbox map instance.
 * @param {object} geojsonData - The GeoJSON FeatureCollection or Feature.
 * @param {object} options - Optional Mapbox fitBounds options (padding, maxZoom, duration, etc.).
 */
export function fitMapToBounds(map, geojsonData, options = {}) {
    if (!map) {
        console.error("fitMapToBounds: Map instance is required.");
        return;
    }
     if (!map.isStyleLoaded()) {
         console.warn("fitMapToBounds: Style not loaded yet. Retrying on 'idle'.");
         map.once('idle', () => fitMapToBounds(map, geojsonData, options));
         return;
     }
    if (!geojsonData) {
        console.error("fitMapToBounds: GeoJSON data is required.");
        return;
    }

    const bounds = getGeoJsonBounds(geojsonData);

    if (bounds) {
        // Sensible defaults, especially padding
        const defaultOptions = {
            padding: { top: 50, bottom: 80, left: 50, right: 50 }, // Adjust padding as needed
            maxZoom: 16, // Prevent zooming in too close
            duration: 1000 // Animation duration in ms
        };

        // Adjust right padding dynamically based on sidebar visibility and width
        const sidebar = document.getElementById('sidebar');
        let sidebarWidth = 0;
        if (sidebar) {
             // Check if the sidebar is actually visible (not just present in DOM)
             const sidebarVisible = window.getComputedStyle(sidebar).display !== 'none';
             if (sidebarVisible) {
                 sidebarWidth = sidebar.offsetWidth || 350; // Use offsetWidth for actual rendered width
                 // console.log("Sidebar detected, width:", sidebarWidth);
             }
        }
        // Add sidebar width to right padding only if it's visible
        defaultOptions.padding.right = (options.padding?.right ?? 50) + sidebarWidth;
        // Ensure left padding isn't affected unless explicitly passed in options
        defaultOptions.padding.left = options.padding?.left ?? 50;
        defaultOptions.padding.top = options.padding?.top ?? 50;
        defaultOptions.padding.bottom = options.padding?.bottom ?? 80; // Keep bottom padding for timeline

        // Merge default options with user-provided options
        const fitOptions = { ...defaultOptions, ...options, padding: defaultOptions.padding }; // Ensure padding object is updated correctly

        // console.log("Fitting map to bounds:", bounds, "with options:", fitOptions);
        try {
            map.fitBounds(bounds, fitOptions);
        } catch (error) {
             console.error("Error calling map.fitBounds:", error);
        }
    } else {
        console.warn("Could not calculate valid bounds for the provided GeoJSON. Map view not changed.");
    }
}

/**
 * Calculates the average presence for a specific KML feature at a given timeline hour index.
 * Considers only records matching the day of the week derived from the index.
 * @param {object} kmlFeature - The KML feature object (must have properties.poi_data_available and properties.poi_name).
 * @param {object} poiData - The global POI data store.
 * @param {number} timelineHourIndex - The hour index (0-167) from the timeline.
 * @returns {{averagePresence: number, recordCount: number}} Object with calculated average and number of records used.
 */
export function calculateAveragePresenceForFeature(kmlFeature, poiData, timelineHourIndex) {
    // --- Input Validation ---
    if (!kmlFeature?.properties?.poi_data_available || !poiData) {
        // console.log("KML feature lacks POI data or poiData store is missing.");
        return { averagePresence: 0, recordCount: 0 };
    }

    const poiName = kmlFeature.properties.poi_name;
    if (!poiName || typeof poiName !== 'string') {
        console.warn("KML feature has invalid 'poi_name' property:", kmlFeature.properties);
        return { averagePresence: 0, recordCount: 0 };
    }

    // Normalize POI name for lookup
    const normalizedPoiName = poiName.trim().toLowerCase();
    const poiRecords = poiData[normalizedPoiName];

    if (!poiRecords || !Array.isArray(poiRecords) || poiRecords.length === 0) {
        // console.log(`No POI records found for normalized name: '${normalizedPoiName}'`);
        return { averagePresence: 0, recordCount: 0 };
    }

    const { jsDayOfWeek, hour } = getDateTimeFromIndex(timelineHourIndex);
    if (jsDayOfWeek === -1 || hour === -1) {
        console.warn("Invalid timelineHourIndex provided:", timelineHourIndex);
        return { averagePresence: 0, recordCount: 0 };
    }

    // Determine the correct column name for presence data at the given hour
    const presenzeKey = `presenze_${hour}`; // Assumes column names like "presenze_0", "presenze_1", ...

    // --- Calculation ---
    let sumPresenzeOra = 0;
    let count = 0;

    poiRecords.forEach(record => {
        // Check if the record has a valid parsedDate and matches the day of the week
        if (record.parsedDate instanceof Date && !isNaN(record.parsedDate.getTime())) {
            // Check day of week match (UTC day needed as parsedDate is UTC)
            if (record.parsedDate.getUTCDay() === jsDayOfWeek) {
                 // Check if the presence key exists and is a number
                if (record.hasOwnProperty(presenzeKey)) {
                    const presenceValue = record[presenzeKey];
                    // Try to convert to number, handle potential strings
                    const numValue = parseFloat(presenceValue);

                    if (!isNaN(numValue)) {
                        sumPresenzeOra += numValue;
                        count++;
                    } else {
                        // Optional: Log if a value exists but isn't a number
                        // console.warn(`Record for ${normalizedPoiName} on ${record.parsedDate.toISOString().slice(0,10)} has non-numeric value for ${presenzeKey}:`, presenceValue);
                    }
                }
            }
        } else {
            // Optional: Log records without valid dates if needed for debugging
            // console.warn("POI record skipped due to invalid 'parsedDate':", record);
        }
    });

    // Calculate the average, handle division by zero
    const averagePresence = count > 0 ? sumPresenzeOra / count : 0;

    // console.log(`Calculated average presence for ${poiName} at index ${timelineHourIndex} (${hourToLabel(timelineHourIndex)}): ${averagePresence.toFixed(2)} from ${count} records.`);
    return { averagePresence, recordCount: count };
}


/**
 * Generates a GeoJSON FeatureCollection of points randomly distributed within a KML feature's polygon.
 * The number of points is based on the average presence, adjusted by a density factor.
 * A portion of points are marked as 'static'.
 * @param {object} kmlFeature - The KML feature (GeoJSON format) with a Polygon or MultiPolygon geometry.
 * @param {number} averagePresence - The calculated average presence for this feature.
 * @returns {object | null} A GeoJSON FeatureCollection of points, or null if error/no points.
 */
export function generatePointsForFeature(kmlFeature, averagePresence) {
    // Check if Turf.js is loaded
    if (typeof turf === 'undefined') {
        console.error("Turf.js is not loaded. Cannot generate points.");
        return null;
    }

    // Validate input KML feature and geometry
    if (!kmlFeature || !kmlFeature.geometry || !['Polygon', 'MultiPolygon'].includes(kmlFeature.geometry.type)) {
        console.warn("generatePointsForFeature: Invalid KML feature or geometry type.", kmlFeature);
        return null;
    }
    // Validate averagePresence
    const validAveragePresence = typeof averagePresence === 'number' && !isNaN(averagePresence) ? averagePresence : 0;
    if (validAveragePresence <= 0) {
        // console.log("generatePointsForFeature: Average presence is zero or negative, no points generated.");
        return null; // No points needed if average presence is zero or less
    }

    // --- Calculate Number of Points ---
    // Adjust point count based on density factor, ensuring it's an integer
    let numPoints = Math.round(validAveragePresence / PRESENCE_POINTS_DENSITY_FACTOR);
    // Apply maximum limit
    numPoints = Math.min(numPoints, MAX_PRESENCE_POINTS);
    // Ensure at least one point if average presence > 0 and factor allows
    numPoints = Math.max(numPoints, (validAveragePresence > 0 && PRESENCE_POINTS_DENSITY_FACTOR > 0) ? 1 : 0);

    if (numPoints <= 0) {
        // console.log("generatePointsForFeature: Calculated number of points is zero.");
        return null;
    }

    // Determine static vs attractable points (percentuale da config)
    const staticPointsCount = Math.ceil(numPoints * PRESENCE_STATIC_POINTS_RATIO);
    const attractablePointsCount = numPoints - staticPointsCount;

    // --- Generate Points ---
    try {
        const generatedPointsFeatures = [];
        const bbox = turf.bbox(kmlFeature.geometry); // Calculate bounding box for random point generation

        // Use a maximum attempt limit to prevent infinite loops if placing points is difficult
        const maxAttempts = numPoints * 15; // Allow more attempts per point
        let attempts = 0;

        // Generate static points
        let staticPointsGenerated = 0;
        while (staticPointsGenerated < staticPointsCount && attempts < maxAttempts) {
            attempts++;
            const randomPos = turf.randomPosition(bbox); // Generate random coordinates within bbox
            const randomPt = turf.point(randomPos);

            // Check if the point is actually inside the polygon (bbox is just a square)
            if (turf.booleanPointInPolygon(randomPt, kmlFeature.geometry)) {
                randomPt.properties = {
                    kmlFeatureId: kmlFeature.id, // Link point back to its KML area
                    isStatic: true              // Mark as static
                };
                generatedPointsFeatures.push(randomPt);
                staticPointsGenerated++;
            }
        }

        // Generate attractable points
        let attractablePointsGenerated = 0;
        while (attractablePointsGenerated < attractablePointsCount && attempts < maxAttempts) {
             attempts++;
             const randomPos = turf.randomPosition(bbox);
             const randomPt = turf.point(randomPos);

             if (turf.booleanPointInPolygon(randomPt, kmlFeature.geometry)) {
                 randomPt.properties = {
                     kmlFeatureId: kmlFeature.id,
                     isStatic: false, // Mark as attractable
                     noiseSeedX: Math.floor(Math.random() * 1000000),
                     noiseSeedY: Math.floor(Math.random() * 1000000)
                 };
                 generatedPointsFeatures.push(randomPt);
                 attractablePointsGenerated++;
             }
        }

        if (generatedPointsFeatures.length === 0 && numPoints > 0) {
             console.warn(`Could not generate any points for feature ${kmlFeature.id} despite trying ${attempts} times.`);
             return null;
        }
        if (generatedPointsFeatures.length < numPoints) {
             console.warn(`Generated only ${generatedPointsFeatures.length}/${numPoints} points for feature ${kmlFeature.id} after ${attempts} attempts.`);
        }

        // Return a valid GeoJSON FeatureCollection
        return turf.featureCollection(generatedPointsFeatures);

    } catch (error) {
        console.error(`Error generating presence points with Turf.js for feature ${kmlFeature.id}:`, error);
        return null; // Return null on error
    }
}

/**
 * Esporta un array di oggetti in formato CSV e avvia il download (browser).
 * @param {Array<object>} data - Array di oggetti da esportare.
 * @param {string} filename - Nome del file da scaricare.
 */
export function exportArrayToCSV(data, filename = 'export.csv') {
    if (!Array.isArray(data) || data.length === 0) {
        alert('Nessun dato da esportare.');
        return;
    }
    // Prendi tutte le chiavi uniche (header)
    const headers = Array.from(
        data.reduce((set, row) => {
            Object.keys(row).forEach(k => set.add(k));
            return set;
        }, new Set())
    );
    // Genera le righe CSV
    const csvRows = [
        headers.join(','),
        ...data.map(row =>
            headers.map(h => {
                let val = row[h] !== undefined ? row[h] : '';
                if (typeof val === 'string' && (val.includes(',') || val.includes('"') || val.includes('\n'))) {
                    val = '"' + val.replace(/"/g, '""') + '"';
                }
                return val;
            }).join(',')
        )
    ];
    const csvContent = csvRows.join('\n');
    // Crea blob e link per download
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    if (link.download !== undefined) {
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }
}

// --- Perlin Noise 2D semplice per animazioni (non crittograficamente sicuro) ---
// Basato su https://github.com/joeiddon/perlin/blob/master/perlin.js
export function perlin2d(x, y, seed = 0) {
    function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
    function lerp(a, b, t) { return a + t * (b - a); }
    function grad(hash, x, y) {
        const h = hash & 3;
        return ((h & 1) ? -x : x) + ((h & 2) ? -y : y);
    }
    function hash(x, y) {
        let h = x * 374761393 + y * 668265263 + seed * 982451653;
        h = (h ^ (h >> 13)) * 1274126177;
        return h & 255;
    }
    const X = Math.floor(x), Y = Math.floor(y);
    const xf = x - X, yf = y - Y;
    const tl = hash(X, Y), tr = hash(X + 1, Y), bl = hash(X, Y + 1), br = hash(X + 1, Y + 1);
    const u = fade(xf), v = fade(yf);
    const x1 = lerp(grad(tl, xf, yf), grad(tr, xf - 1, yf), u);
    const x2 = lerp(grad(bl, xf, yf - 1), grad(br, xf - 1, yf - 1), u);
    return lerp(x1, x2, v) * 0.5 + 0.5; // Normalizzato tra 0 e 1
}